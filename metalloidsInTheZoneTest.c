#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, dgtl11,  limitClaw,      sensorTouch)
#pragma config(Sensor, dgtl12,  limitArm,       sensorTouch)
#pragma config(Motor,  port1,           moGoLeft,      tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port4,           intakeClaw,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           upperArm,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lowerArm,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           intakeArm,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           backLeft,      tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port9,           backRight,     tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port10,          moGoRight,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void base();
void pArm(int armTarget);
void moGoManip();
int armTargetAdjustment();
void intakeArmMovement();

#define armPot_UPPER 2200
#define armPot_LOWER 500
#define kP 0.1
#define frameRate 20

//models a control scheme between 2 buttons to one motor, one for each direction. Returns -1, 0, or 1 given the 2 buttons.
int between(int control1, int control2){
	if(vexRT[control1] ^ vexRT[control2]){
		return vexRT[control1] ? 1 : -1;
	}
	return 0;
}


task main()
{
	int prevBtn8U = 0;
	int clawState = 0;
	int armTarget = SensorValue[armPot];
	while(true){
		base();

		armTarget += armTargetAdjustment() * frameRate;
		if(armTarget >= armPot_UPPER){armTarget = armPot_UPPER;}
		else if(armTarget <= armPot_LOWER){armTarget = armPot_LOWER;}
		pArm(armTarget);

		moGoManip();
		intakeArmMovement();

		//claw logic, swaps between open and closed. Stops immidiately if limit is triggered.
		if(prevBtn8U==1 && vexRT[Btn8U]==0){
				if(clawState == 0){motor[intakeClaw] = 30; clawState = 1;}
				else if(clawState == 1){motor[intakeClaw] = -30; clawState = 0;}
		}
		if(SensorValue[limitClaw] == 1 && clawState == 0){
			motor[intakeClaw] = 0;
		}

		prevBtn8U = vexRT[Btn8U];
		wait1Msec(frameRate);
	}
}

void base(){
	motor[frontLeft] = vexRT[Ch3];
	motor[frontRight] = vexRT[Ch2];
	motor[backLeft] = vexRT[Ch3];
	motor[backRight] = vexRT[Ch2];
}

void pArm(int armTarget)
{
	int error = armTarget - SensorValue[armPot];

	int motorPower = error * kP;

	motor[upperArm] = motorPower;
	motor[lowerArm] = motorPower;
}

int armTargetAdjustment ()
{
	return between(Btn6U,Btn6D);
}

void intakeArmMovement(){
	motor[intakeArm] = -127*between(Btn5U, Btn5D);
}

void moGoManip()
{
	motor[moGoLeft] = 127*between(Btn7U, Btn7D);
	motor[moGoRight] = 127*between(Btn7U, Btn7D);
}
